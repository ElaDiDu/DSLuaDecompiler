using System;
using System.Collections.Generic;
using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Analyzers;

/// <summary>
/// Analyzer that identifies identifiers that are likely to be local variables and therefore should not have their
/// definitions inlined into other expressions.
/// </summary>
public class LocalVariablesAnalyzer : IAnalyzer
{
    private readonly HashSet<Identifier> _localVariables = new(10);

    public IReadOnlySet<Identifier> LocalVariables => _localVariables;

    public void Run(DecompilationContext decompilationContext, FunctionContext functionContext, Function function)
    {
        var dominance = functionContext.GetAnalysis<DominanceAnalyzer>();
        
        // GetDefines and GetUses calls have a lot of allocation overhead so reusing the same set has huge perf gains.
        var definesSet = new HashSet<Identifier>(2);
        var usesSet = new HashSet<Identifier>(10);
        
        // Lua function calls (and expressions in general) have their bytecode generated recursively.
        // This means for example when doing a function call, the name of the function is loaded to a register first,
        // then all the subexpressions are computed, and finally the function is called. We can exploit this knowledge
        // to determine which expressions were actually inlined into the function call in the original source code.
        // This analysis finds the pre-propagation index in the instruction list of each instruction as well as the
        // index of the first definition instruction contributing to a function call expression.
        var defines = new Dictionary<Identifier, int>();
        var selfIdentifiers = new HashSet<Identifier>();
        foreach (var b in function.BlockList)
        {
            defines.Clear();
            selfIdentifiers.Clear();
            for (var i = 0; i < b.Instructions.Count; i++)
            {
                if (b.Instructions[i].GetSingleDefine(true) is { } define)
                {
                    defines.Add(define, b.Instructions[i].InstructionIndices.Begin);
                    if (b.Instructions[i] is Assignment { IsSelfAssignment: true })
                    {
                        selfIdentifiers.Add(define);
                    }
                }

                switch (b.Instructions[i])
                {
                    case Assignment { Right: FunctionCall { Function: IdentifierReference fir } fc }:
                    {
                        fc.FunctionDefIndex = defines[fir.Identifier];
                        if (selfIdentifiers.Contains(fir.Identifier))
                        {
                            // If a self op was used, the first arg will be loaded before the function name
                            fc.FunctionDefIndex--;
                        }

                        break;
                    }
                    // Detect tail calls
                    case Return { ReturnExpressions.Count: 1 } r when r.ReturnExpressions[0] is FunctionCall
                    {
                        Function: IdentifierReference fir2
                    } fc2:
                    {
                        fc2.FunctionDefIndex = defines[fir2.Identifier];
                        if (selfIdentifiers.Contains(fir2.Identifier))
                        {
                            // If a self op was used, the first arg will be loaded before the function name
                            fc2.FunctionDefIndex--;
                        }

                        break;
                    }
                }
            }
        }
        
        // Lua, with its simple one-pass compiler, doesn't really have a register allocation algorithm of any kind.
        // Local variables are allocated to a single register for the lifetime of the entire scope, while temp locals
        // generated by the compiler for complex expressions only have a lifetime for that expression (i.e. once the
        // expression is done evaluating, that register is free to be used in that scope again. Of course, we can
        // exploit this to figure out local variables in the original source code even if they only had one use:
        // If the next register defined within the scope (dominance hierarchy) after the first use of a recently
        // defined register is not that register, then it's likely an actual local variable.
        int LocalIdentifyVisit(CFG.BasicBlock b, HashSet<uint> localRegs)
        {
            var thisLocalRegs = new HashSet<uint>(localRegs.Count * 2);
            thisLocalRegs.UnionWith(localRegs);

            // Set of defines that are never used in this block (very very likely to be locals)
            var unusedDefines = new HashSet<Identifier>(b.Instructions.Count / 2);

            // Set of recently used registers that are candidates for locals
            var recentlyUsed = new Dictionary<uint, Identifier>(b.Instructions.Count / 2);
            for (var i = 0; i < b.Instructions.Count; i++)
            {
                // First add registers such the set contains all the registers used up to this point
                usesSet.Clear();
                b.Instructions[i].GetUses(usesSet, true);
                foreach (var use in usesSet)
                {
                    // If it's used it's no longer an unused definition
                    if (unusedDefines.Contains(use))
                    {
                        unusedDefines.Remove(use);
                    }
                    
                    if (thisLocalRegs.Contains(use.RegNum))
                    {
                        // Already marked as a local
                        continue;
                    }

                    if (_localVariables.Contains(use))
                    {
                        // Add it to the local regs
                        thisLocalRegs.Add(use.RegNum);
                        continue;
                    }

                    if (!recentlyUsed.ContainsKey(use.RegNum))
                    {
                        recentlyUsed.Add(use.RegNum, use);
                    }
                    else
                    {
                        // Double use. Definitely a local
                        _localVariables.Add(use);
                        thisLocalRegs.Add(use.RegNum);
                        recentlyUsed.Remove(use.RegNum);
                    }
                }

                definesSet.Clear();
                b.Instructions[i].GetDefines(definesSet, true);

                // If this is a multi-assignment then these variables are almost certainly locals
                if (definesSet.Count > 1)
                {
                    foreach (var def in definesSet)
                    {
                        // Unfortunately this pretty much kills any previous def of this in scope's chances to actually
                        // be a local
                        if (recentlyUsed.ContainsKey(def.RegNum))
                        {
                            recentlyUsed.Remove(def.RegNum);
                            _localVariables.Add(def);
                            thisLocalRegs.Add(def.RegNum);
                        }
                    }
                }
                // This is more interesting
                else if (definesSet.Count == 1)
                {
                    // Self instructions have a lot of information because they always use the next available temp
                    // registers. This means that any pending uses below us that haven't been redefined yet are actually
                    // locals. Note that the SELF op actually translates to two IR ops with two registers used, so we
                    // account for that
                    if (b.Instructions[i] is Assignment { IsSelfAssignment: true })
                    {
                        var def2 = b.Instructions[i + 1].GetSingleDefine(true) ?? throw new Exception();

                        foreach (var k in recentlyUsed.Keys)
                        {
                            // If the reg number is less than the second define then it's a local
                            if (k < def2.RegNum)
                            {
                                _localVariables.Add(recentlyUsed[k]);
                                thisLocalRegs.Add(k);
                            }
                        }

                        recentlyUsed.Clear();
                        i++;
                        continue;
                    }

                    var def = b.Instructions[i].GetSingleDefine(true) ?? throw new Exception();

                    // Skip upValue
                    if (function.ClosureBound(def))
                    {
                        continue;
                    }

                    // Move on if it's a known local
                    if (thisLocalRegs.Contains(def.RegNum))
                    {
                        // Make sure the def is marked as local
                        _localVariables.Add(def);
                        continue;
                    }

                    // Add the new def to the unused defs until it's used otherwise
                    unusedDefines.Add(def);

                    // Otherwise a quick redefine is likely a temp. Mark below as locals and above as temps
                    if (recentlyUsed.ContainsKey(def.RegNum))
                    {
                        foreach (var k in recentlyUsed.Keys)
                        {
                            // If the reg number is less than the second define then it's a local
                            if (k < def.RegNum)
                            {
                                _localVariables.Add(recentlyUsed[k]);
                                thisLocalRegs.Add(k);
                            }
                        }

                        recentlyUsed.Clear();
                        continue;
                    }
                    
                    // We're now seeing a new register defined. Anything left in recently used is probably a local
                    /*foreach (var ru in recentlyUsed)
                    {
                        definitelyLocal.Add()
                    }*/
                }
            }

            // Any unused defines at this point are locals
            foreach (var unused in unusedDefines)
            {
                _localVariables.Add(unused);
                thisLocalRegs.Add(unused.RegNum);
            }

            // Visit next blocks in scope. Here we get the lowest register defined in the successor blocks that
            // isn't already a redefinition of an already identified local, as that represents the baseline of what
            // the Lua compiler can select for a new temporary register. Any pending registers used in this block
            // that have a register number below that are very likely to be local variables since Lua doesn't select
            // them for temporaries.
            var childFirstNonLocalDefine = int.MaxValue;
            dominance.RunOnDominanceTreeSuccessors(function, b, successor =>
            {
                var fd = LocalIdentifyVisit(successor, thisLocalRegs);
                if (fd < childFirstNonLocalDefine && fd != -1)
                {
                    childFirstNonLocalDefine = fd;
                }
            });

            if (childFirstNonLocalDefine != int.MaxValue)
            {
                foreach (var k in recentlyUsed.Keys)
                {
                    // If the reg number is less than the first assigned register in the dominance successors that
                    // isn't a redefinition of an already identified local, then k likely represents a local since
                    // the Lua compiler isn't selecting it for a temporary or new local.
                    if (k < childFirstNonLocalDefine)
                    {
                        _localVariables.Add(recentlyUsed[k]);
                        thisLocalRegs.Add(k);
                    }
                }
            }

            // Find the register of the first non-local define to return
            var firstTempDef = -1;
            foreach (var inst in b.Instructions)
            {
                if (inst.GetSingleDefine(true) is { } def)
                {
                    if (!localRegs.Contains(def.RegNum) && !function.ClosureBound(def))
                    {
                        firstTempDef = (int)def.RegNum;
                        if (inst is Assignment { IsSelfAssignment: true })
                        {
                            // Again a SELF op generates two assignments-the second one being the lower reg number
                            firstTempDef--;
                        }
                        break;
                    }
                }
            }
            return firstTempDef;
        }
        
        var argRegisters = new HashSet<uint>();
        for (uint i = 0; i < function.ParameterCount; i++)
        {
            argRegisters.Add(i);
        }
        LocalIdentifyVisit(function.BeginBlock, new HashSet<uint>(argRegisters));
    }
    
    public void Dispose()
    {
    }
}