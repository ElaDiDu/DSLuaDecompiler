using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Passes;

/// <summary>
/// Super simple analysis that eliminates assignments of the form:
/// REGA = REGA
/// 
/// These are often generated by the TEST instruction and elimination of these simplifies things for future passes
/// </summary>
public class EliminateRedundantAssignmentsPass : IPass
{
    public void RunOnFunction(DecompilationContext context, Function f)
    {
        foreach (var b in f.BlockList)
        {
            for (int i = 0; i < b.Instructions.Count; i++)
            {
                // If we encounter a closure we must skip instructions equal to the number of upvalues, as the assignments that follow are
                // critical for upvalue binding analysis
                if (b.Instructions[i] is Assignment a && a.Right is Closure c)
                {
                    i += c.Function.UpValueCount;
                }
                else if (b.Instructions[i] is Assignment assn && assn.LeftList.Count == 1 && !assn.LeftList[0].HasIndex)
                {
                    if (assn.Right is IdentifierReference { HasIndex: false } reference &&
                        assn.LeftList[0].Identifier == reference.Identifier)
                    {
                        b.Instructions.RemoveAt(i);
                        i--;
                    }
                }
            }
        }
    }
}