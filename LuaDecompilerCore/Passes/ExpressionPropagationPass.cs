using System.Collections.Generic;
using System.Linq;
using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Passes;

/// <summary>
/// Performs expression propagation which substitutes register definitions into their users to build more complex
/// expressions
/// </summary>
public class ExpressionPropagationPass : IPass
{
    private bool _firstPass;

    public ExpressionPropagationPass(bool firstPass)
    {
        _firstPass = firstPass;
    }
    
    public void RunOnFunction(DecompilationContext context, Function f)
    {
        // Lua function calls (and expressions in general have their bytecode generated recursively. This means for example when doing a function call,
        // the name of the function is loaded to a register first, then all the subexpressions are computed, and finally the function is called. We can
        // exploit this knowledge to determine which expressions were actually inlined into the function call in the original source code.
        if (_firstPass)
        {
            foreach (var b in f.BlockList)
            {
                var defines = new Dictionary<Identifier, int>();
                var selfs = new HashSet<Identifier>();
                for (int i = 0; i < b.Instructions.Count; i++)
                {
                    b.Instructions[i].PrePropagationIndex = i;
                    var defs = b.Instructions[i].GetDefines(true);
                    if (defs.Count == 1)
                    {
                        defines.Add(defs.First(), i);
                        if (b.Instructions[i] is Assignment a2 && a2.IsSelfAssignment)
                        {
                            selfs.Add(defs.First());
                        }
                    }
                    switch (b.Instructions[i])
                    {
                        case Assignment { Right: FunctionCall { Function: IdentifierReference fir } fc }:
                        {
                            fc.FunctionDefIndex = defines[fir.Identifier];
                            if (selfs.Contains(fir.Identifier))
                            {
                                // If a self op was used, the first arg will be loaded before the function name
                                fc.FunctionDefIndex--;
                            }

                            break;
                        }
                        // Detect tail calls
                        case Return r when r.ReturnExpressions.Count == 1 && r.ReturnExpressions[0] is FunctionCall
                        {
                            Function: IdentifierReference fir2
                        } fc2:
                        {
                            fc2.FunctionDefIndex = defines[fir2.Identifier];
                            if (selfs.Contains(fir2.Identifier))
                            {
                                // If a self op was used, the first arg will be loaded before the function name
                                fc2.FunctionDefIndex--;
                            }

                            break;
                        }
                    }
                }
            }
        }

        // Lua, with its simple one-pass compiler, doesn't really have a register allocation algorithm of any kind. Local variables are allocated to
        // a single register for the lifetime of the entire scope, while temp locals generated by the compiler for complex expressions only have a
        // lifetime for that expression (i.e. once the expression is done evaluating, that register is free to be used in that scope again. Of course,
        // we can exploit this to figure out local variables in the original source code even if they only had one use: If the next register defined
        // within the scope (dominance hierarchy) after the first use of a recently defined register is not that register, then it's likely an actual
        // local variable.
        int LocalIdentifyVisit(CFG.BasicBlock b, HashSet<Identifier> localRegs)
        {
            HashSet<Identifier> thisLocalRegs = new HashSet<Identifier>();
            thisLocalRegs.UnionWith(localRegs);

            // Set of defines that are never used in this block (very very likely to be locals)
            HashSet<Identifier> unusedDefines = new HashSet<Identifier>();

            // Set of recently used registers that are candidates for locals
            Dictionary<Identifier, Identifier> recentlyUsed = new Dictionary<Identifier, Identifier>();
            for (int i = 0; i < b.Instructions.Count; i++)
            {
                // First add registers such the set contains all the registers used up to this point
                foreach (var use in b.Instructions[i].GetUses(true))
                {
                    // If it's used it's no longer an unused definition
                    if (unusedDefines.Contains(use))
                    {
                        unusedDefines.Remove(use);
                    }

                    if (thisLocalRegs.Contains(use.OriginalIdentifier))
                    {
                        // Already marked as a local
                        continue;
                    }

                    if (f.LocalVariables.Contains(use))
                    {
                        // Add it to the local regs
                        thisLocalRegs.Add(use.OriginalIdentifier);
                        continue;
                    }

                    if (!recentlyUsed.ContainsKey(use.OriginalIdentifier))
                    {
                        recentlyUsed.Add(use.OriginalIdentifier, use);
                    }
                    else
                    {
                        // Double use. Definitely a local
                        f.LocalVariables.Add(use);
                        thisLocalRegs.Add(use.OriginalIdentifier);
                        recentlyUsed.Remove(use.OriginalIdentifier);
                    }
                }

                bool removed = false;

                var defines = b.Instructions[i].GetDefines(true);

                // If this is a multiassignment then these variables are almost certainly locals
                if (defines.Count > 1)
                {
                    foreach (var def in defines)
                    {
                        // Unfortunately this pretty much kills any previous def of this in scope's chances to actually be a local
                        if (recentlyUsed.ContainsKey(def.OriginalIdentifier))
                        {
                            recentlyUsed.Remove(def.OriginalIdentifier);
                        }
                        f.LocalVariables.Add(def);
                        thisLocalRegs.Add(def.OriginalIdentifier);
                    }
                }
                // This is more interesting
                else if (defines.Count == 1)
                {
                    // Self instructions have a lot of information because they always use the next available temp registers. This
                    // means that any pending uses below us that haven't been redefined yet are actually locals. Note that the SELF
                    // op actually translates to two IR ops with two registers used, so we account for that
                    if (b.Instructions[i] is Assignment self && self.IsSelfAssignment)
                    {
                        var def1 = defines.First();
                        var def2 = b.Instructions[i + 1].GetDefines(true).First(); // Second instruction

                        foreach (var k in recentlyUsed.Keys)
                        {
                            // If the reg number is less than the second define then it's a local
                            if (k.RegNum < def2.OriginalIdentifier.RegNum)
                            {
                                f.LocalVariables.Add(recentlyUsed[k]);
                                thisLocalRegs.Add(k);
                            }
                        }
                        recentlyUsed.Clear();
                        i++;
                        continue;
                    }

                    var def = defines.First();

                    // Skip upvalue
                    if (def.IsClosureBound || def.Renamed)
                    {
                        continue;
                    }

                    // Move on if it's a known local
                    if (thisLocalRegs.Contains(def.OriginalIdentifier))
                    {
                        // Make sure the def is marked as local
                        f.LocalVariables.Add(def);
                        continue;
                    }

                    // Add the new def to the unused defs until it's used otherwise
                    unusedDefines.Add(def);

                    // Otherwise a quick redefine is likely a temp. Mark below as locals and above as temps
                    if (recentlyUsed.ContainsKey(def.OriginalIdentifier))
                    {
                        foreach (var k in recentlyUsed.Keys)
                        {
                            // If the reg number is less than the second define then it's a local
                            if (k.RegNum < def.OriginalIdentifier.RegNum)
                            {
                                f.LocalVariables.Add(recentlyUsed[k]);
                                thisLocalRegs.Add(k);
                            }
                        }
                        recentlyUsed.Clear();
                        continue;
                    }

                    // We're now seeing a new register defined. Anything left in recently used is probably a local
                    /*foreach (var ru in recentlyUsed)
                    {
                        definitelyLocal.Add()
                    }*/
                }
            }

            // Any unused defines at this point are locals
            foreach (var unused in unusedDefines)
            {
                f.LocalVariables.Add(unused);
                thisLocalRegs.Add(unused.OriginalIdentifier);
            }

            // Visit next blocks in scope
            var childFirstDef = int.MaxValue;
            foreach (var succ in b.DominanceTreeSuccessors)
            {
                var fd = LocalIdentifyVisit(succ, thisLocalRegs);
                if (fd < childFirstDef && fd != -1)
                {
                    childFirstDef = fd;
                }
            }

            // Localize remaining identifiers with reg numbers below the first presumed temp define in the following blocks in scope
            if (childFirstDef != -1 && childFirstDef != int.MaxValue)
            {
                foreach (var k in recentlyUsed.Keys)
                {
                    // If the reg number is less than the second define then it's a local
                    if (k.RegNum < childFirstDef)
                    {
                        f.LocalVariables.Add(recentlyUsed[k]);
                        thisLocalRegs.Add(k);
                    }
                }
            }

            // Find the register of the first non-local define to return
            int firstTempDef = -1;
            foreach (var inst in b.Instructions)
            {
                var defs = inst.GetDefines(true);
                if (defs.Count == 1)
                {
                    var def = defs.First();
                    if (!f.LocalVariables.Contains(def) && !def.Renamed && !def.IsClosureBound)
                    {
                        firstTempDef = (int)def.OriginalIdentifier.RegNum;
                        if (inst is Assignment self && self.IsSelfAssignment)
                        {
                            // Again a SELF op generates two assignments-the second one being the lower reg number
                            firstTempDef--;
                        }
                        break;
                    }
                }
            }
            return firstTempDef;
        }
        if (_firstPass)
        {
            var argregs = new HashSet<Identifier>();
            foreach (var i in f.Parameters)
            {
                argregs.Add(i.OriginalIdentifier);
            }
            LocalIdentifyVisit(f.BeginBlock, new HashSet<Identifier>(argregs));
        }

        bool changed;
        do
        {
            changed = false;
            foreach (var b in f.BlockList)
            {
                for (int i = 0; i < b.Instructions.Count; i++)
                {
                    var inst = b.Instructions[i];
                    foreach (var use in inst.GetUses(true))
                    {
                        if (use.DefiningInstruction is Assignment a &&
                            a.Left.Count == 1 && a.LocalAssignments == null &&
                            ((use.UseCount == 1 && ((i - 1 >= 0 && b.Instructions[i - 1] == use.DefiningInstruction) || inst is Assignment
                            {
                                IsListAssignment: true
                            }) && !f.LocalVariables.Contains(use)) || a.PropogateAlways) &&
                            !a.Left[0].Identifier.IsClosureBound)
                        {
                            // Don't substitute if this use's define was defined before the code gen for the function call even began
                            if (!a.PropogateAlways && inst is Assignment a3 && a3.Right is FunctionCall fc && (use.DefiningInstruction.PrePropagationIndex < fc.FunctionDefIndex))
                            {
                                continue;
                            }
                            if (!a.PropogateAlways && inst is Return r && r.ReturnExpressions.Count == 1 && r.ReturnExpressions[0] is FunctionCall fc2 && (use.DefiningInstruction.PrePropagationIndex < fc2.FunctionDefIndex))
                            {
                                continue;
                            }
                            var replaced = inst.ReplaceUses(use, a.Right);
                            if (a.Block != null && replaced)
                            {
                                changed = true;
                                a.Block.Instructions.Remove(a);
                                f.SsaVariables.Remove(use);
                                if (b == a.Block)
                                {
                                    //i--;
                                    i = -1;
                                }
                            }
                        }
                    }
                }
            }

            // Lua might generate the following (decompiled) code when doing a this call on a global variable:
            //     REG0 = someGlobal
            //     REG0:someFunction(blah...)
            // This rewrites such statements to
            //     someGlobal:someFunction(blah...)
            foreach (var b in f.BlockList)
            {
                for (int i = 0; i < b.Instructions.Count; i++)
                {
                    var inst = b.Instructions[i];
                    if (inst is Assignment { Right: FunctionCall fc } a && fc.Args.Count > 0 &&
                        fc.Args[0] is IdentifierReference { HasIndex: false } ir && ir.Identifier.UseCount == 2 &&
                        i > 0 && b.Instructions[i - 1] is Assignment a2 && a2.Left.Count == 1 &&
                        !a2.Left[0].HasIndex && a2.Left[0].Identifier == ir.Identifier &&
                        a2.Right is IdentifierReference or Constant)
                    {
                        a.ReplaceUses(a2.Left[0].Identifier, a2.Right);
                        b.Instructions.RemoveAt(i - 1);
                        i--;
                        changed = true;
                    }
                }
            }
        } while (changed);
    }
}