using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using LuaDecompilerCore.Analyzers;
using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Passes;

/// <summary>
/// Performs expression propagation which substitutes register definitions into their users to build more complex
/// expressions
/// </summary>
public class ExpressionPropagationPass : IPass
{
    private readonly bool _firstPass;

    public ExpressionPropagationPass(bool firstPass)
    {
        _firstPass = firstPass;
    }
    
    public void RunOnFunction(DecompilationContext context, Function f)
    {
        // GetDefines and GetUses calls have a lot of allocation overhead so reusing the same set has huge perf gains.
        var definesSet = new HashSet<Identifier>(2);
        var usesSet = new HashSet<Identifier>(10);
        
        // Lua function calls (and expressions in general have their bytecode generated recursively. This means for example when doing a function call,
        // the name of the function is loaded to a register first, then all the subexpressions are computed, and finally the function is called. We can
        // exploit this knowledge to determine which expressions were actually inlined into the function call in the original source code.
        if (_firstPass)
        {
            foreach (var b in f.BlockList)
            {
                var defines = new Dictionary<Identifier, int>();
                var selfs = new HashSet<Identifier>();
                for (var i = 0; i < b.Instructions.Count; i++)
                {
                    b.Instructions[i].PrePropagationIndex = i;
                    if (b.Instructions[i].GetSingleDefine(true) is { } define)
                    {
                        defines.Add(define, i);
                        if (b.Instructions[i] is Assignment { IsSelfAssignment: true })
                        {
                            selfs.Add(define);
                        }
                    }
                    switch (b.Instructions[i])
                    {
                        case Assignment { Right: FunctionCall { Function: IdentifierReference fir } fc }:
                        {
                            fc.FunctionDefIndex = defines[fir.Identifier];
                            if (selfs.Contains(fir.Identifier))
                            {
                                // If a self op was used, the first arg will be loaded before the function name
                                fc.FunctionDefIndex--;
                            }

                            break;
                        }
                        // Detect tail calls
                        case Return { ReturnExpressions.Count: 1 } r when r.ReturnExpressions[0] is FunctionCall
                        {
                            Function: IdentifierReference fir2
                        } fc2:
                        {
                            fc2.FunctionDefIndex = defines[fir2.Identifier];
                            if (selfs.Contains(fir2.Identifier))
                            {
                                // If a self op was used, the first arg will be loaded before the function name
                                fc2.FunctionDefIndex--;
                            }

                            break;
                        }
                    }
                }
            }
        }

        // Lua, with its simple one-pass compiler, doesn't really have a register allocation algorithm of any kind. Local variables are allocated to
        // a single register for the lifetime of the entire scope, while temp locals generated by the compiler for complex expressions only have a
        // lifetime for that expression (i.e. once the expression is done evaluating, that register is free to be used in that scope again. Of course,
        // we can exploit this to figure out local variables in the original source code even if they only had one use: If the next register defined
        // within the scope (dominance hierarchy) after the first use of a recently defined register is not that register, then it's likely an actual
        // local variable.
        int LocalIdentifyVisit(CFG.BasicBlock b, HashSet<uint> localRegs)
        {
            var thisLocalRegs = new HashSet<uint>(localRegs.Count * 2);
            thisLocalRegs.UnionWith(localRegs);

            // Set of defines that are never used in this block (very very likely to be locals)
            var unusedDefines = new HashSet<Identifier>(b.Instructions.Count / 2);

            // Set of recently used registers that are candidates for locals
            var recentlyUsed = new Dictionary<uint, Identifier>(b.Instructions.Count / 2);
            for (var i = 0; i < b.Instructions.Count; i++)
            {
                // First add registers such the set contains all the registers used up to this point
                usesSet.Clear();
                b.Instructions[i].GetUses(usesSet, true);
                foreach (var use in usesSet)
                {
                    // If it's used it's no longer an unused definition
                    if (unusedDefines.Contains(use))
                    {
                        unusedDefines.Remove(use);
                    }
                    
                    if (thisLocalRegs.Contains(use.RegNum))
                    {
                        // Already marked as a local
                        continue;
                    }

                    if (f.LocalVariables.Contains(use))
                    {
                        // Add it to the local regs
                        thisLocalRegs.Add(use.RegNum);
                        continue;
                    }

                    if (!recentlyUsed.ContainsKey(use.RegNum))
                    {
                        recentlyUsed.Add(use.RegNum, use);
                    }
                    else
                    {
                        // Double use. Definitely a local
                        f.LocalVariables.Add(use);
                        thisLocalRegs.Add(use.RegNum);
                        recentlyUsed.Remove(use.RegNum);
                    }
                }

                var removed = false;

                definesSet.Clear();
                b.Instructions[i].GetDefines(definesSet, true);

                // If this is a multi-assignment then these variables are almost certainly locals
                if (definesSet.Count > 1)
                {
                    foreach (var def in definesSet)
                    {
                        // Unfortunately this pretty much kills any previous def of this in scope's chances to actually be a local
                        if (recentlyUsed.ContainsKey(def.RegNum))
                        {
                            recentlyUsed.Remove(def.RegNum);
                            f.LocalVariables.Add(def);
                            thisLocalRegs.Add(def.RegNum);
                        }
                    }
                }
                // This is more interesting
                else if (definesSet.Count == 1)
                {
                    // Self instructions have a lot of information because they always use the next available temp registers. This
                    // means that any pending uses below us that haven't been redefined yet are actually locals. Note that the SELF
                    // op actually translates to two IR ops with two registers used, so we account for that
                    if (b.Instructions[i] is Assignment { IsSelfAssignment: true })
                    {
                        var def2 = b.Instructions[i + 1].GetSingleDefine(true) ?? throw new Exception();

                        foreach (var k in recentlyUsed.Keys)
                        {
                            // If the reg number is less than the second define then it's a local
                            if (k < def2.RegNum)
                            {
                                f.LocalVariables.Add(recentlyUsed[k]);
                                thisLocalRegs.Add(k);
                            }
                        }

                        recentlyUsed.Clear();
                        i++;
                        continue;
                    }

                    var def = b.Instructions[i].GetSingleDefine(true) ?? throw new Exception();

                    // Skip upValue
                    if (f.ClosureBound(def))
                    {
                        continue;
                    }

                    // Move on if it's a known local
                    if (thisLocalRegs.Contains(def.RegNum))
                    {
                        // Make sure the def is marked as local
                        f.LocalVariables.Add(def);
                        continue;
                    }

                    // Add the new def to the unused defs until it's used otherwise
                    unusedDefines.Add(def);

                    // Otherwise a quick redefine is likely a temp. Mark below as locals and above as temps
                    if (recentlyUsed.ContainsKey(def.RegNum))
                    {
                        foreach (var k in recentlyUsed.Keys)
                        {
                            // If the reg number is less than the second define then it's a local
                            if (k < def.RegNum)
                            {
                                f.LocalVariables.Add(recentlyUsed[k]);
                                thisLocalRegs.Add(k);
                            }
                        }

                        recentlyUsed.Clear();
                        continue;
                    }
                    
                    // We're now seeing a new register defined. Anything left in recently used is probably a local
                    /*foreach (var ru in recentlyUsed)
                    {
                        definitelyLocal.Add()
                    }*/
                }
            }

            // Any unused defines at this point are locals
            foreach (var unused in unusedDefines)
            {
                f.LocalVariables.Add(unused);
                thisLocalRegs.Add(unused.RegNum);
            }

            // Visit next blocks in scope
            var childFirstDef = int.MaxValue;
            foreach (var successor in b.DominanceTreeSuccessors)
            {
                var fd = LocalIdentifyVisit(successor, thisLocalRegs);
                if (fd < childFirstDef && fd != -1)
                {
                    childFirstDef = fd;
                }
            }

            // Localize remaining identifiers with reg numbers below the first presumed temp define in the following blocks in scope
            if (childFirstDef != int.MaxValue)
            {
                foreach (var k in recentlyUsed.Keys)
                {
                    // If the reg number is less than the second define then it's a local
                    if (k < childFirstDef)
                    {
                        f.LocalVariables.Add(recentlyUsed[k]);
                        thisLocalRegs.Add(k);
                    }
                }
            }

            // Find the register of the first non-local define to return
            var firstTempDef = -1;
            foreach (var inst in b.Instructions)
            {
                if (inst.GetSingleDefine(true) is { } def)
                {
                    if (!f.LocalVariables.Contains(def) && !f.ClosureBound(def))
                    {
                        firstTempDef = (int)def.RegNum;
                        if (inst is Assignment { IsSelfAssignment: true })
                        {
                            // Again a SELF op generates two assignments-the second one being the lower reg number
                            firstTempDef--;
                        }
                        break;
                    }
                }
            }
            return firstTempDef;
        }
        if (_firstPass)
        {
            var argRegisters = new HashSet<uint>();
            for (uint i = 0; i < f.ParameterCount; i++)
            {
                argRegisters.Add(i);
            }
            LocalIdentifyVisit(f.BeginBlock, new HashSet<uint>(argRegisters));
        }

        var defineUseAnalysis = new IdentifierDefinitionUseAnalyzer();
        defineUseAnalysis.Run(f);

        bool changed;
        do
        {
            changed = false;
            foreach (var b in f.BlockList)
            {
                for (var i = 1; i < b.Instructions.Count; i++)
                {
                    var inst = b.Instructions[i];
                    usesSet.Clear();
                    inst.GetUses(usesSet, true);
                    foreach (var use in usesSet)
                    {
                        var definingInstruction = defineUseAnalysis.DefiningInstruction(use);
                        if (definingInstruction is Assignment
                            {
                                IsSingleAssignment: true, 
                                LocalAssignments: null, 
                                Right: not null
                            } a &&
                            ((defineUseAnalysis.UseCount(use) == 1 && 
                              ((i - 1 >= 0 && b.Instructions[i - 1] == definingInstruction) || 
                               inst is Assignment { IsListAssignment: true }) && 
                              !f.LocalVariables.Contains(use)) || 
                             a.PropagateAlways) && !f.ClosureBound(a.Left.Identifier))
                        {
                            // Don't substitute if this use's define was defined before the code gen for the function call even began
                            if (!a.PropagateAlways && inst is Assignment { Right: FunctionCall fc } && 
                                definingInstruction.PrePropagationIndex < fc.FunctionDefIndex)
                            {
                                continue;
                            }
                            if (!a.PropagateAlways && inst is Return r && r.ReturnExpressions.Count == 1 && 
                                r.ReturnExpressions[0] is FunctionCall fc2 && 
                                definingInstruction.PrePropagationIndex < fc2.FunctionDefIndex)
                            {
                                continue;
                            }
                            var replaced = inst.ReplaceUses(use, a.Right);
                            if (a.Block != null && replaced)
                            {
                                changed = true;
                                a.Block.Instructions.Remove(a);
                                f.SsaVariables.Remove(use);
                                if (b == a.Block)
                                {
                                    //i--;
                                    i = -1;
                                }
                            }
                        }
                    }
                }
            }

            // Lua might generate the following (decompiled) code when doing a this call on a global variable:
            //     REG0 = someGlobal
            //     REG0:someFunction(blah...)
            // This rewrites such statements to
            //     someGlobal:someFunction(blah...)
            foreach (var b in f.BlockList)
            {
                for (var i = 0; i < b.Instructions.Count; i++)
                {
                    var inst = b.Instructions[i];
                    if (inst is Assignment { Right: FunctionCall { Args.Count: > 0 } fc } a &&
                        fc.Args[0] is IdentifierReference { HasIndex: false } ir &&
                        defineUseAnalysis.UseCount(ir.Identifier) == 2 &&
                        i > 0 && b.Instructions[i - 1] is Assignment { IsSingleAssignment: true, Left.HasIndex: false } a2 && 
                        a2.Left.Identifier == ir.Identifier &&
                        a2.Right is IdentifierReference or Constant)
                    {
                        a.ReplaceUses(a2.Left.Identifier, a2.Right);
                        b.Instructions.RemoveAt(i - 1);
                        i--;
                        changed = true;
                    }
                }
            }
        } while (changed);
    }
}