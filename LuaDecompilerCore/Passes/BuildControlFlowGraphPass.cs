using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using LuaDecompilerCore.CFG;
using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Passes;

/// <summary>
/// Takes a function that only has a single basic block and models control flow as jumps to labels and builds a proper
/// control flow graph. This splits the basic block into many basic blocks with their own instruction stream and are
/// linked together by edges from jumps and conditional jumps.
/// </summary>
public class BuildControlFlowGraphPass : IPass
{
    public void RunOnFunction(DecompilationContext context, Function f)
    {
        // Before CFG creation there should be only a single block. Save the instructions and clear the block list
        Debug.Assert(f.BlockList.Count == 1);
        var instructions = f.BlockList[0].Instructions;
        f.BlockList.Clear();
        
        // Create the begin and end basic blocks
        f.BeginBlock = f.CreateAndAddBasicBlock();
        f.EndBlock = f.CreateBasicBlock();

        // These are used to connect jmps to their destinations later
        var labelBasicBlockMap = new Dictionary<Label, BasicBlock>();

        bool cullNextReturn = false;

        // First pass: Build all the basic blocks using labels, jmps, and rets as boundries
        var currentBlock = f.BeginBlock;
        for (int i = 0; i < instructions.Count; i++)
        {
            switch (instructions[i])
            {
                // Unconditional jumps just start a new basic block
                case Jump { Conditional: false } jmp:
                {
                    currentBlock.Instructions.Add(jmp);
                    jmp.Block = currentBlock;
                    currentBlock = f.CreateAndAddBasicBlock();
                    if (i + 1 < instructions.Count && instructions[i+1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Conditional jumps has the following block as a successor
                case Jump { Conditional: true } jmp2:
                {
                    currentBlock.Instructions.Add(jmp2);
                    jmp2.Block = currentBlock;
                    var newBlock = f.CreateAndAddBasicBlock();
                    currentBlock.Successors.Add(newBlock);
                    newBlock.Predecessors.Add(currentBlock);
                    currentBlock = newBlock;
                    if (i + 1 < instructions.Count && instructions[i + 1] is Label l)
                    {
                        if (l == jmp2.Dest)
                        {
                            // Empty if statement. Generate a dummy block so the true block and else block are different
                            var newblock2 = f.CreateAndAddBasicBlock();
                            currentBlock.Instructions.Add(new Jump(l));
                            currentBlock = newblock2;
                        }
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Returns simply go directly to the end block, and starts a new basic block if not at the end
                case Return ret when AnalysisOpts.AnalyzeReturns:
                {
                    currentBlock.Instructions.Add(ret);
                    ret.Block = currentBlock;
                    currentBlock.Successors.Add(f.EndBlock);
                    f.EndBlock.Predecessors.Add(currentBlock);
                    if (i + 1 < instructions.Count)
                    {
                        currentBlock = f.CreateAndAddBasicBlock();
                    }

                    if (i + 1 < instructions.Count && instructions[i + 1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Alternate return analysis for lua 5.0
                case Return ret when !cullNextReturn:
                {
                    // If a tailcall was done, an extra return that's not needed will always be generated by the Lua 5.0 compiler
                    if (ret.IsTailReturn)
                    {
                        cullNextReturn = true;
                    }
                    currentBlock.Instructions.Add(ret);
                    ret.Block = currentBlock;
                    break;
                }
                case Return:
                    cullNextReturn = false;
                    break;
                // Other labels just start a new fallthrough basic block
                case Label l2:
                {
                    var newBlock =f.CreateAndAddBasicBlock();
                    currentBlock.Successors.Add(newBlock);
                    newBlock.Predecessors.Add(currentBlock);
                    currentBlock = newBlock;
                    labelBasicBlockMap.Add(l2, currentBlock);
                    break;
                }
                // Otherwise add instruction to the block
                default:
                    currentBlock.Instructions.Add(instructions[i]);
                    instructions[i].Block = currentBlock;
                    break;
            }
        }

        // Second pass: Connect jumps to their basic blocks
        foreach (var b in f.BlockList)
        {
            if (b.Instructions.Count > 0 && b.Instructions.Last() is Jump jmp)
            {
                b.Successors.Add(labelBasicBlockMap[jmp.Dest]);
                labelBasicBlockMap[jmp.Dest].Predecessors.Add(b);
                jmp.BlockDest = labelBasicBlockMap[jmp.Dest];
            }
        }

        // Third pass: Remove unreachable blocks
        for (int b = 0; b < f.BlockList.Count; b++)
        {
            // Begin block has no predecessors but shouldn't be removed because :)
            if (f.BlockList[b] == f.BeginBlock)
            {
                continue;
            }
            if (f.BlockList[b].Predecessors.Count == 0)
            {
                foreach (var successor in f.BlockList[b].Successors)
                {
                    successor.Predecessors.Remove(f.BlockList[b]);
                }
                f.BlockList.RemoveAt(b);
                b--;
            }
        }

        // Forth pass: Merge blocks that have a single successor and that successor has a single predecessor
        bool changed = true;
        while (changed)
        {
            changed = false;
            for (int b = 0; b < f.BlockList.Count; b++)
            {
                if (f.BlockList[b].Successors.Count == 1 && f.BlockList[b].Successors[0].Predecessors.Count == 1 &&
                    (f.BlockList[b].Instructions.Last() is Jump ||
                     (b + 1 < f.BlockList.Count && f.BlockList[b].Successors[0] == f.BlockList[b + 1])))
                {
                    var current = f.BlockList[b];
                    var successor = f.BlockList[b].Successors[0];
                    if (f.BlockList[b].Instructions.Last() is Jump)
                    {
                        current.Instructions.RemoveAt(current.Instructions.Count - 1);
                    }
                    foreach (var inst in successor.Instructions)
                    {
                        inst.Block = current;
                    }
                    current.Instructions.AddRange(successor.Instructions);
                    current.Successors = successor.Successors;
                    foreach (var s in successor.Successors)
                    {
                        for (int p = 0; p < s.Predecessors.Count; p++)
                        {
                            if (s.Predecessors[p] == successor)
                            {
                                s.Predecessors[p] = current;
                            }
                        }
                    }
                    f.BlockList.Remove(successor);
                    b = Math.Max(0, b - 2);
                    changed = true;
                }
            }
        }

        // Dangling no successor blocks should go to the end block (implicit return)
        foreach (var b in f.BlockList)
        {
            if (b == f.EndBlock)
            {
                continue;
            }
            if (b.Successors.Count == 0)
            {
                b.Successors.Add(f.EndBlock);
                f.EndBlock.Predecessors.Add(b);
            }
        }

        f.BlockList.Add(f.EndBlock);
    }
}