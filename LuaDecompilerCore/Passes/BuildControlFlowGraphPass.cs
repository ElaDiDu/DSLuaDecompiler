using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using LuaDecompilerCore.CFG;
using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Passes;

/// <summary>
/// Takes a function that only has a single basic block and models control flow as jumps to labels and builds a proper
/// control flow graph. This splits the basic block into many basic blocks with their own instruction stream and are
/// linked together by edges from jumps and conditional jumps.
/// </summary>
public class BuildControlFlowGraphPass : IPass
{
    public bool MutatesCfg => true;
    
    public bool RunOnFunction(DecompilationContext decompilationContext, FunctionContext functionContext, Function f)
    {
        // Before CFG creation there should be only a single block. Save the instructions and clear the block list
        Debug.Assert(f.BlockList.Count == 1);
        var instructions = f.BlockList[0].Instructions;
        f.BlockList.Clear();
        
        // Create the begin and end basic blocks
        f.BeginBlock = f.CreateAndAddBasicBlock();
        f.EndBlock = f.CreateBasicBlock();

        // These are used to connect jumps to their destinations later
        var labelBasicBlockMap = new Dictionary<Label, BasicBlock>();

        var cullNextReturn = false;

        // First pass: Build all the basic blocks using labels, jmps, and rets as boundries
        var currentBlock = f.BeginBlock;
        for (var i = 0; i < instructions.Count; i++)
        {
            switch (instructions[i])
            {
                // Unconditional jumps just start a new basic block
                case JumpLabel jmp:
                {
                    currentBlock.AddInstruction(jmp);
                    currentBlock = f.CreateAndAddBasicBlock();
                    if (i + 1 < instructions.Count && instructions[i+1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Conditional jumps has the following block as a successor
                case ConditionalJumpLabel jmp2:
                {
                    currentBlock.AddInstruction(jmp2);
                    var newBlock = f.CreateAndAddBasicBlock();
                    currentBlock.AddSuccessor(newBlock);
                    currentBlock = newBlock;
                    if (i + 1 < instructions.Count && instructions[i + 1] is Label l)
                    {
                        if (l == jmp2.Destination)
                        {
                            // Empty if statement. Generate a dummy block so the true block and else block are different
                            newBlock = f.CreateAndAddBasicBlock();
                            currentBlock.AddInstruction(new JumpLabel(l));
                            currentBlock = newBlock;
                        }
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Returns simply go directly to the end block, and starts a new basic block if not at the end
                case Return ret when AnalysisOpts.AnalyzeReturns:
                {
                    currentBlock.AddInstruction(ret);
                    currentBlock.AddSuccessor(f.EndBlock);
                    if (i + 1 < instructions.Count)
                    {
                        currentBlock = f.CreateAndAddBasicBlock();
                    }

                    if (i + 1 < instructions.Count && instructions[i + 1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Alternate return analysis for lua 5.0
                case Return ret when !cullNextReturn:
                {
                    // If a tail call was done, an extra return that's not needed will always be generated by the Lua 5.0 compiler
                    if (ret.IsTailReturn)
                    {
                        cullNextReturn = true;
                    }
                    currentBlock.AddInstruction(ret);
                    break;
                }
                case Return:
                    cullNextReturn = false;
                    break;
                // Other labels just start a new fallthrough basic block
                case Label l2:
                {
                    var newBlock = f.CreateAndAddBasicBlock();
                    currentBlock.AddSuccessor(newBlock);
                    currentBlock = newBlock;
                    labelBasicBlockMap.Add(l2, currentBlock);
                    break;
                }
                // Otherwise add instruction to the block
                default:
                    currentBlock.AddInstruction(instructions[i]);
                    break;
            }
        }

        // Second pass: Connect jumps to their basic blocks
        foreach (var b in f.BlockList)
        {
            if (b is { HasInstructions: true, Last: IJumpLabel jmp })
            {
                var destination = labelBasicBlockMap[jmp.Destination];
                b.AddSuccessor(destination);
                Instruction jmpInstruction = b.Last;
                b.Last = jmp switch
                {
                    JumpLabel => new Jump(destination),
                    ConditionalJumpLabel j => new ConditionalJump(destination, j.Condition),
                    _ => throw new Exception()
                };
                b.Last.DefinedRegisters = jmpInstruction.DefinedRegisters;
                b.Last.InlinedRegisters = jmpInstruction.InlinedRegisters;
                b.Last.InstructionIndices = jmpInstruction.InstructionIndices;
                b.Last.OriginalBlock = b.BlockId;
                
                // If there is a post taken assignment, place it in the destination block
                if (jmp is ConditionalJumpLabel { PostTakenAssignment: { } assignment })
                {
                    destination.InsertInstruction(0, assignment);
                    assignment.PropagateAlways = true;
                }
            }
        }

        // Third pass: Remove unreachable blocks
        for (var b = 0; b < f.BlockList.Count; b++)
        {
            // Begin block has no predecessors but shouldn't be removed because :)
            if (f.BlockList[b] == f.BeginBlock)
            {
                continue;
            }
            if (f.BlockList[b].Predecessors.Count == 0)
            {
                foreach (var successor in f.BlockList[b].Successors)
                {
                    successor.Predecessors.Remove(f.BlockList[b]);
                }
                f.BlockList.RemoveAt(b);
                b--;
            }
        }

        // Forth pass: Merge blocks that have a single successor and that successor has a single predecessor
        var changed = true;
        while (changed)
        {
            changed = false;
            for (var b = 0; b < f.BlockList.Count; b++)
            {
                if (f.BlockList[b].Successors.Count == 1 && f.BlockList[b].Successors[0].Predecessors.Count == 1 &&
                    (f.BlockList[b].Last is Jump || 
                     (b + 1 < f.BlockList.Count && f.BlockList[b].Successors[0] == f.BlockList[b + 1])))
                {
                    var current = f.BlockList[b];
                    var successor = f.BlockList[b].Successors[0];
                    if (f.BlockList[b].Last is Jump)
                    {
                        current.Instructions.RemoveAt(current.Instructions.Count - 1);
                    }
                    foreach (var inst in successor.Instructions)
                    {
                        inst.OriginalBlock = current.BlockId;
                    }
                    current.Instructions.AddRange(successor.Instructions);
                    current.Successors = successor.Successors;
                    foreach (var s in successor.Successors)
                    {
                        for (var p = 0; p < s.Predecessors.Count; p++)
                        {
                            if (s.Predecessors[p] == successor)
                            {
                                s.Predecessors[p] = current;
                            }
                        }
                    }
                    f.BlockList.Remove(successor);
                    b = Math.Max(0, b - 2);
                    changed = true;
                }
            }
        }

        // Dangling no successor blocks should go to the end block (implicit return)
        foreach (var b in f.BlockList)
        {
            if (b == f.EndBlock)
            {
                continue;
            }
            if (b.Successors.Count == 0)
            {
                b.AddSuccessor(f.EndBlock);
            }
        }

        f.BlockList.Add(f.EndBlock);

        return true;
    }
}