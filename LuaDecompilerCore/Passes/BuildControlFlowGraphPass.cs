using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using LuaDecompilerCore.CFG;
using LuaDecompilerCore.IR;

namespace LuaDecompilerCore.Passes;

/// <summary>
/// Takes a function that only has a single basic block and models control flow as jumps to labels and builds a proper
/// control flow graph. This splits the basic block into many basic blocks with their own instruction stream and are
/// linked together by edges from jumps and conditional jumps.
/// </summary>
public class BuildControlFlowGraphPass : IPass
{
    public bool MutatesCfg => true;
    
    public bool RunOnFunction(DecompilationContext decompilationContext, FunctionContext functionContext, Function f)
    {
        // Before CFG creation there should be only a single block. Save the instructions and clear the block list
        Debug.Assert(f.BlockList.Count == 1);
        var instructions = f.BlockList[0].Instructions;
        f.ClearBlocks();
        
        // Create the begin and end basic blocks
        f.BeginBlock = f.CreateAndAddBasicBlock();
        f.EndBlock = f.CreateBasicBlock(true);

        // These are used to connect jumps to their destinations later
        var labelBasicBlockMap = new Dictionary<Label, BasicBlock>();

        var cullNextReturn = false;

        // First pass: Build all the basic blocks using labels, jmps, and rets as boundaries
        var currentBlock = f.BeginBlock;
        for (var i = 0; i < instructions.Count; i++)
        {
            switch (instructions[i])
            {
                // Unconditional jumps just start a new basic block
                case JumpLabel jmp:
                {
                    currentBlock.AddInstruction(jmp);
                    currentBlock = f.CreateAndAddBasicBlock();
                    if (i + 1 < instructions.Count && instructions[i+1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Conditional jumps has the following block as a successor
                case ConditionalJumpLabel jmp2:
                {
                    currentBlock.AddInstruction(jmp2);
                    currentBlock.KilledLocals = jmp2.KilledLocals;
                    var newBlock = f.CreateAndAddBasicBlock();
                    currentBlock.AddSuccessor(newBlock);
                    currentBlock = newBlock;
                    if (i + 1 < instructions.Count && instructions[i + 1] is Label l)
                    {
                        if (l == jmp2.Destination)
                        {
                            // Empty if statement. Generate a dummy block so the true block and else block are different
                            newBlock = f.CreateAndAddBasicBlock();
                            currentBlock.AddInstruction(new JumpLabel(l));
                            currentBlock.IsEmptyIf = true;
                            currentBlock = newBlock;
                        }
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Returns simply go directly to the end block, and starts a new basic block if not at the end
                case Return ret when AnalysisOpts.AnalyzeReturns:
                {
                    currentBlock.AddInstruction(ret);
                    currentBlock.AddSuccessor(f.EndBlock);
                    if (i + 1 < instructions.Count)
                    {
                        currentBlock = f.CreateAndAddBasicBlock();
                    }

                    if (i + 1 < instructions.Count && instructions[i + 1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }

                    break;
                }
                // Alternate return analysis for lua 5.0
                case Return ret when !cullNextReturn:
                {
                    // If a tail call was done, an extra return that's not needed will always be generated by the Lua 5.0 compiler
                    if (ret.IsTailReturn)
                    {
                        cullNextReturn = true;
                    }
                    currentBlock.AddInstruction(ret);
                    break;
                }
                case Return:
                    cullNextReturn = false;
                    break;
                // Other labels just start a new fallthrough basic block
                case Label l2:
                {
                    var newBlock = f.CreateAndAddBasicBlock();
                    currentBlock.AddSuccessor(newBlock);
                    currentBlock = newBlock;
                    labelBasicBlockMap.Add(l2, currentBlock);
                    break;
                }
                // Otherwise add instruction to the block
                default:
                    currentBlock.AddInstruction(instructions[i]);
                    break;
            }
        }

        // Second pass: Connect jumps to their basic blocks
        foreach (var b in f.BlockList)
        {
            if (b is { HasInstructions: true, Last: IJumpLabel jmp })
            {
                var destination = labelBasicBlockMap[jmp.Destination];
                b.AddSuccessor(destination);
                Instruction jmpInstruction = b.Last;
                b.Last = jmp switch
                {
                    JumpLabel => new Jump(destination),
                    ConditionalJumpLabel j => new ConditionalJump(destination, j.Condition),
                    _ => throw new Exception()
                };
                b.Last.DefinedRegisters = jmpInstruction.DefinedRegisters;
                b.Last.InlinedRegisters = jmpInstruction.InlinedRegisters;
                b.Last.InstructionIndices = jmpInstruction.InstructionIndices;
                b.Last.OriginalBlock = b.BlockId;
                
                // If there is a post taken assignment, place it in the destination block
                if (jmp is ConditionalJumpLabel { PostTakenAssignment: { } assignment })
                {
                    destination.InsertInstruction(0, assignment);
                    assignment.PropagateAlways = true;
                }
            }
        }

        // Third pass: Attempt to resolve unreachable blocks by transforming them into an "if false"
        for (var b = 0; b < f.BlockList.Count; b++)
        {
            // Begin block has no predecessors but shouldn't be removed because :)
            if (f.BlockList[b] == f.BeginBlock)
            {
                continue;
            }
            if (f.BlockList[b].Predecessors.Count == 0)
            {
                if (f.BlockList[b - 1].Successors.Count == 1 && f.BlockList[b - 1].Last is Jump j)
                {
                    f.BlockList[b].Predecessors.Add(f.BlockList[b - 1]);
                    f.BlockList[b - 1].Successors.Insert(0, f.BlockList[b]);
                    f.BlockList[b - 1].Last = new ConditionalJump(j.Destination, new Constant(false, -1));
                    f.BlockList[b - 1].Last.DefinedRegisters = j.DefinedRegisters;
                    f.BlockList[b - 1].Last.InlinedRegisters = j.InlinedRegisters;
                    f.BlockList[b - 1].Last.InstructionIndices = j.InstructionIndices;
                    f.BlockList[b - 1].Last.OriginalBlock = j.OriginalBlock;
                }
            }
        }
        
        // Forth pass: Remove unreachable blocks that can't be resolved
        for (var b = 0; b < f.BlockList.Count; b++)
        {
            // Begin block has no predecessors but shouldn't be removed because :)
            if (f.BlockList[b] == f.BeginBlock)
            {
                continue;
            }
            if (f.BlockList[b].Predecessors.Count == 0)
            {
                foreach (var successor in f.BlockList[b].Successors)
                {
                    successor.Predecessors.Remove(f.BlockList[b]);
                }
                f.RemoveBlockAt(b);
                b--;
            }
        }

        // Dangling no successor blocks should go to the end block (implicit return)
        foreach (var b in f.BlockList)
        {
            if (b == f.EndBlock)
            {
                continue;
            }
            if (b.Successors.Count == 0)
            {
                b.AddSuccessor(f.EndBlock);
            }
        }

        f.AddBasicBlock(f.EndBlock);

        return true;
    }
}