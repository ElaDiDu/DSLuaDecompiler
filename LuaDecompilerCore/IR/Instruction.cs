using System;
using System.Collections.Generic;
using LuaDecompilerCore.Utilities;

namespace LuaDecompilerCore.IR
{
    /// <summary>
    /// A single instruction or statement, initially translated from a Lua opcode,
    /// but can be simplified into more powerful "instructions"
    /// </summary>
    public abstract class Instruction : IIrNode
    {
        /// <summary>
        /// The original lua bytecode op within the function that generated this instruction
        /// </summary>
        public int OpLocation = -1;

        /// <summary>
        /// The original block ID that this instruction was in
        /// </summary>
        public int OriginalBlock = -1;
        
        /// <summary>
        /// Range of instruction indices in the original IR that this instruction represents
        /// </summary>
        public Interval InstructionIndices;

        /// <summary>
        /// Range of registers that were defined (assigned) in the original IR that this instruction
        /// represents
        /// </summary>
        public Interval DefinedRegisters;

        /// <summary>
        /// Cumulative range of registers that have their assignments inlined into this one through expression
        /// propagation. The main difference between this and the defined registers interval is that this one doesn't
        /// contain the registers this instruction immediately defines.
        /// </summary>
        public Interval InlinedRegisters;

        /// <summary>
        /// Assignments generated by the Lua self op are always temporary, so keep track of the highest self assigned
        /// register defined or inlined into this expression.
        /// </summary>
        public int SelfAssignMinRegister = int.MaxValue;

        /// <summary>
        /// Register numbers that are this number and above are always temporary registers entering this instruction.
        /// </summary>
        public int AlwaysTemporaryRegister = int.MaxValue;
        
        public bool HasClosure => MatchAny(e => e is Closure);
        
        /// <summary>
        /// True if this is an assignment instruction that assigns a closure
        /// </summary>
        public bool IsClosureAssignment => this is Assignment { Right: Closure };

        /// <summary>
        /// True if this instruction pattern matches to a function declaration
        /// </summary>
        public bool IsFunctionDeclaration => this is Assignment
        {
            IsSingleAssignment: true,
            Left: IdentifierReference { Identifier.IsGlobal: true },
            Right: Closure
        };
        
        public virtual void Parenthesize() { }

        /// <summary>
        /// "Absorbs" another instruction by updating bookkeeping ranges associated with the other instruction.
        /// Use this when you replace another instruction and make this one the superset (such as when inlining).
        /// </summary>
        /// <param name="instruction"></param>
        public void Absorb(Instruction instruction)
        {
            InstructionIndices = InstructionIndices.UnionWith(instruction.InstructionIndices);
            DefinedRegisters = DefinedRegisters.UnionWith(instruction.DefinedRegisters);
            InlinedRegisters = InlinedRegisters.UnionWith(instruction.DefinedRegisters);
            SelfAssignMinRegister = Math.Min(SelfAssignMinRegister, instruction.SelfAssignMinRegister);
        }

        /// <summary>
        /// Gets all the identifiers that are defined by this instruction and adds them to the input set
        /// </summary>
        public virtual HashSet<Identifier> GetDefinedRegisters(HashSet<Identifier> defines)
        {
            return defines;
        }
        
        /// <summary>
        /// Gets all the identifiers that are used (but not defined) by this instruction and adds them
        /// to the input set
        /// </summary>
        public virtual HashSet<Identifier> GetUsedRegisters(HashSet<Identifier> uses)
        {
            return uses;
        }

        /// <summary>
        /// If this instruction defines only a single identifier, return that identifier
        /// </summary>
        /// <returns></returns>
        public virtual Identifier? GetSingleDefine()
        {
            return null;
        }

        public virtual List<Expression> GetExpressions()
        {
            return new List<Expression>();
        }

        public virtual void RenameDefines(Identifier original, Identifier newIdentifier) { }

        public virtual void RenameUses(Identifier original, Identifier newIdentifier) { }

        public virtual bool ReplaceUses(Identifier orig, Expression sub) { return false; }

        public virtual int UseCount(Identifier use) { return 0; }
        
        public override string ToString()
        {
            return FunctionPrinter.DebugPrintInstruction(this);
        }

        public virtual bool MatchAny(Func<IIrNode, bool> condition)
        {
            return condition.Invoke(this);
        }
        
        public virtual void IterateUses(Action<IIrNode, UseType, IdentifierReference> function) { }

        protected void IterateUsesSuccessor(IIrNode expression, UseType useType, 
            Action<IIrNode, UseType, IdentifierReference> function)
        {
            if (expression is IdentifierReference { Identifier: { IsRegister:true } } ir)
                function.Invoke(this, useType, ir);
            else
                expression.IterateUses(function);
        }
    }
}
